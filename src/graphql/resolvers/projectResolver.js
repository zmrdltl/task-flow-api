import mongoose from 'mongoose';
import { authMiddleware } from '../../middlewares/authMiddleware.js';
import { Project, Member, Role, Task, Comment } from '../../models/index.js';
import { getIsClicked, getLikeCount } from '../../utils/commentUtils.js';
const projectResolver = {
  Query: {
    getProjects: async (_, __, context) => {
      try {
        const userData = await authMiddleware({ request: context.request });
        const member = await Member.findOne({ email: userData.email });

        const projects = await Project.find()
          .populate({
            path: 'members',
            populate: { path: 'role' },
          })
          .populate({
            path: 'tasks',
            populate: [
              { path: 'managers' },
              {
                path: 'subTasks',
                populate: [
                  { path: 'managers' },
                  {
                    path: 'comments',
                    populate: [{ path: 'memberId' }],
                  },
                ],
              },
              {
                path: 'comments',
                populate: [{ path: 'memberId' }],
              },
            ],
          });

        const response = await Promise.all(
          projects.map((project) => ({
            ...project._doc,
            id: project._id.toString(),
            tasks: project.tasks.map((task) => ({
              ...task._doc,
              id: task._id.toString(),
              comments: task.comments.map(async (comment) => ({
                ...comment._doc,
                id: comment._id.toString(),
                member: comment.memberId, // ‚úÖ `memberId`Î•º `member`Î°ú Î≥ÄÌôò
                taskId: comment.taskId ? comment.taskId.toString() : null,
                isClicked: await getIsClicked(comment._id, member._id),
                likeCount: await getLikeCount(comment._id),
              })),
              subTasks: task.subTasks.map((subTask) => ({
                ...subTask._doc,
                id: subTask._id.toString(),
                comments: subTask.comments.map(async (comment) => ({
                  ...comment._doc,
                  id: comment._id.toString(),
                  member: comment.memberId, // ‚úÖ `memberId`Î•º `member`Î°ú Î≥ÄÌôò
                  taskId: comment.taskId ? comment.taskId.toString() : null,
                  isClicked: await getIsClicked(comment._id, member._id),
                  likeCount: await getLikeCount(comment._id),
                })),
              })),
            })),
          }))
        );

        console.log('üìå ÏµúÏ¢Ö Projects:', JSON.stringify(response, null, 2));
        return response;
      } catch (err) {
        throw new Error('Failed to fetch projects');
      }
    },
    getProjectById: async (_, { id }, context) => {
      const userData = await authMiddleware({ request: context.request });
      const member = await Member.findOne({ email: userData.email });

      try {
        const project = await Project.findById(id)
          .populate({
            path: 'members',
            populate: { path: 'role' },
          })
          .populate({
            path: 'tasks',
            populate: [
              { path: 'managers' },
              {
                path: 'subTasks',
                populate: [
                  { path: 'managers' },
                  {
                    path: 'comments',
                    populate: [{ path: 'memberId' }],
                  },
                ],
              },
              {
                path: 'comments',
                populate: [{ path: 'memberId' }],
              },
            ],
          });

        if (!project) throw new Error('Project not found');
        console.log('üìå project:', JSON.stringify(project, null, 2));
        const response = {
          ...project._doc,
          id: project._id.toString(),
          tasks: await Promise.all(
            project.tasks.map(async (task) => ({
              ...task._doc,
              id: task._id.toString(),
              comments: await Promise.all(
                task.comments.map(async (comment) => ({
                  ...comment._doc,
                  id: comment._id.toString(),
                  member: comment.memberId,
                  taskId: comment.taskId ? comment.taskId.toString() : null,
                  isClicked: await getIsClicked(comment._id, member._id),
                  likeCount: await getLikeCount(comment._id),
                }))
              ),
              subTasks: await Promise.all(
                task.subTasks.map(async (subTask) => ({
                  ...subTask._doc,
                  id: subTask._id.toString(),
                  comments: await Promise.all(
                    subTask.comments.map(async (comment) => ({
                      ...comment._doc,
                      id: comment._id.toString(),
                      member: comment.memberId,
                      taskId: comment.taskId ? comment.taskId.toString() : null,
                      isClicked: await getIsClicked(comment._id, member._id),
                      likeCount: await getLikeCount(comment._id),
                    }))
                  ),
                }))
              ),
            }))
          ),
        };

        return response;
      } catch (err) {
        throw new Error('Failed to fetch project');
      }
    },
  },
  Mutation: {
    createProject: async (
      _,
      { name, description, members, endDate },
      context
    ) => {
      // ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú Google ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÌöçÎìù
      const googleUserData = await authMiddleware({ request: context.request });
      try {
        // 1. ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©ÏûêÎ•º Member Ïª¨Î†âÏÖòÏóêÏÑú Ï°∞Ìöå (ÏóÜÏúºÎ©¥ ÏÉùÏÑ±)
        let currentMember = await Member.findOne({
          email: googleUserData.email,
        });
        if (!currentMember) {
          currentMember = new Member({
            googleId: googleUserData.sub,
            email: googleUserData.email,
            nickname: googleUserData.name,
            profileImage: googleUserData.picture,
            isActive: true,
            // projectIdÎäî ÎÇòÏ§ëÏóê ÌîÑÎ°úÏ†ùÌä∏ ÏÉùÏÑ± ÌõÑ ÏóÖÎç∞Ïù¥Ìä∏Ìï† Ïàò ÏûàÏäµÎãàÎã§.
          });
          await currentMember.save();
        }

        // 2. Ï†ÑÎã¨Îêú members Î∞∞Ïó¥Ïóê ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÏùò IDÍ∞Ä ÏóÜÎã§Î©¥ Ï∂îÍ∞Ä

        const membersObjectIds = [
          new mongoose.Types.ObjectId(currentMember._id),
        ];

        // 3. ÌîÑÎ°úÏ†ùÌä∏ ÏÉùÏÑ±
        const project = new Project({
          name,
          description,
          members: membersObjectIds,
          endDate,
        });
        await project.save();

        // 4. ÌîÑÎ°úÏ†ùÌä∏ ÏÉùÏÑ± ÌõÑ, ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÏóêÍ≤å ADMIN Role Î∂ÄÏó¨
        const adminRole = new Role({
          name: 'ADMIN',
          permissions: ['ALL'],
          projectId: project._id,
          memberId: currentMember._id,
        });
        await adminRole.save();

        currentMember.role = adminRole._id;
        await currentMember.save();

        console.log('üìå Admin Role:', adminRole);
        // 5. ÏÉùÏÑ±Îêú ÌîÑÎ°úÏ†ùÌä∏Î•º populate ÌïòÏó¨ Î∞òÌôò
        return await Project.findById(project._id)
          .populate({
            path: 'members',
            populate: { path: 'role' },
          })
          .populate('tasks');
      } catch (err) {
        throw new Error(`Failed to create project: ${err.message}`);
      }
    },
    updateProject: async (
      _,
      { id, name, description, members, tasks, endDate },
      context
    ) => {
      await authMiddleware({ request: context.request });

      try {
        console.log('üìå Received Input:', {
          id,
          name,
          description,
          members,
          endDate,
        });

        const membersObjectIds = members
          ? members.map((m) => new mongoose.Types.ObjectId(m))
          : [];

        const project = await Project.findByIdAndUpdate(
          id,
          { name, description, members: membersObjectIds, endDate },
          { new: true }
        )
          .populate({
            path: 'members',
            populate: { path: 'role' },
          })
          .populate('tasks');

        if (!project)
          throw new Error(`Project with ID ${id} not found or update failed`);

        return project;
      } catch (err) {
        throw new Error(`Failed to update project: ${err.message}`);
      }
    },

    deleteProject: async (_, { id }, context) => {
      await authMiddleware({ request: context.request });

      try {
        const project = await Project.findByIdAndDelete(id);
        if (!project) throw new Error('Project not found');

        // Ïó∞Í¥ÄÎêú Task ÏÇ≠Ï†ú
        await Task.deleteMany({ projectId: project._id });
        // Ïó∞Í¥ÄÎêú Role ÏÇ≠Ï†ú
        await Role.deleteMany({ projectId: project._id });
        return project;
      } catch (err) {
        throw new Error('Failed to delete project');
      }
    },

    createMemberFromProject: async (
      _,
      { projectId, email, name = 'MEMBER', permissions = ['READ_AND_COMMENT'] },
      context
    ) => {
      await authMiddleware({ request: context.request });

      try {
        const project = await Project.findById(projectId);
        if (!project) throw new Error(`Project with ID ${projectId} not found`);

        let member = await Member.findOne({ email });
        if (!member) {
          member = new Member({
            email,
            nickname: email.split('@')[0], // Í∏∞Î≥∏ ÎãâÎÑ§ÏûÑ
            isActive: true,
          });
          await member.save();
        }

        if (project.members.includes(member._id)) {
          throw new Error(
            `Member with email ${email} is already in the project`
          );
        }

        // Role ÏÉùÏÑ±
        const role = new Role({
          name,
          permissions,
          projectId: projectId,
          memberId: member._id,
        });
        await role.save();

        // Member Í∞ùÏ≤¥Ïóê Role Ïó∞Í≤∞
        member.role = role._id;
        await member.save();

        // ÌîÑÎ°úÏ†ùÌä∏Ïóê Î©§Î≤Ñ Ï∂îÍ∞Ä
        project.members.push(member._id);
        await project.save();

        // Member Í∞ùÏ≤¥Î•º role Ï†ïÎ≥¥ÏôÄ Ìï®Íªò populate
        const populatedMember = await Member.findById(member._id).populate(
          'role'
        );

        return {
          member: populatedMember,
          role,
          message: `Member ${email} added to project successfully`,
        };
      } catch (err) {
        throw new Error(`Failed to add member to project: ${err.message}`);
      }
    },

    removeMemberFromProject: async (_, { projectId, memberId }, context) => {
      await authMiddleware({ request: context.request });

      try {
        const project = await Project.findById(projectId);
        if (!project) throw new Error(`Project with ID ${projectId} not found`);

        const member = await Member.findById(memberId);
        if (!member) throw new Error(`Member with ID ${memberId} not found`);

        // 1. ÌîÑÎ°úÏ†ùÌä∏ÏóêÏÑú Î©§Î≤Ñ Ï†úÍ±∞
        await Project.findByIdAndUpdate(
          projectId,
          { $pull: { members: memberId } },
          { new: true }
        );

        // 2. Ìï¥Îãπ Î©§Î≤ÑÏùò Role Ï†úÍ±∞
        await Role.deleteOne({ projectId: projectId, memberId: memberId });

        // 3. Î™®Îì† TaskÏóêÏÑú Ìï¥Îãπ Î©§Î≤ÑÎ•º managersÏóêÏÑú Ï†úÍ±∞ (Î∞∞Ïó¥ ÏóÖÎç∞Ïù¥Ìä∏)
        await Task.updateMany(
          { projectId, managers: memberId }, // ÌîÑÎ°úÏ†ùÌä∏ÏôÄ Ìï¥Îãπ Î©§Î≤ÑÍ∞Ä managersÏóê Ìè¨Ìï®Îêú Î¨∏ÏÑú Ï∞æÍ∏∞
          { $pull: { managers: memberId } } // Ìï¥Îãπ Î©§Î≤Ñ Ï†úÍ±∞
        );

        // 4. Î™®Îì† SubTaskÏóêÏÑú Ìï¥Îãπ Î©§Î≤ÑÎ•º managersÏóêÏÑú Ï†úÍ±∞ (Î∞∞Ïó¥ ÏóÖÎç∞Ïù¥Ìä∏)
        await Task.updateMany(
          { 'subTasks.managers': memberId }, // ÌïòÏúÑ TaskÏóê Ìï¥Îãπ Î©§Î≤ÑÍ∞Ä managersÏóê Ìè¨Ìï®Îêú Í≤ΩÏö∞
          { $pull: { 'subTasks.managers': memberId } } // ÌïòÏúÑ TaskÏóêÏÑú Ìï¥Îãπ Î©§Î≤Ñ Ï†úÍ±∞
        );

        return {
          message: `Member ${member.email} removed from project successfully`,
        };
      } catch (err) {
        throw new Error('Failed to remove member from project');
      }
    },
  },
};

export default projectResolver;
